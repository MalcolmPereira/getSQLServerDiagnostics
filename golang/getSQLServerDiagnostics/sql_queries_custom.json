{	
	"querydoc":{
		"doc_1":"This documentation explains the JSON schema on how the queries should be structured so it can be executed from the program ",
		"doc_2":"querysource element - contains any additional information from where these queries come from, applicable if we are getting the diagnostic queries from some source, we want to acknowledge them.",
		"doc_3":"queries element contains list of queries that we want to execute this is made of on list of queries where each query contains name, description, query and any additional notes",
		"doc_4":"name this contains the name of the query, we want this to be less than or equal to 31 chars with no special chars, this is used to name the worksheet in the generated excel.",
		"doc_5":"description this contains the description for the query we are executing",
		"doc_6":"query this is the actual query to be executed, please format it to be in one line without any chars that will conflict with the JSON structure",
		"doc_7":"notes this is any additional notes you might want to add"
	},
	"querysource":{
		"sqlserverversion":"2022-2025-AzureSQL",
		"name":"2022-2025-AzureSQL",
		"author":"Glenn Berry/Adam Machanic -https://github.com/amachanic/sp_whoisactive/releases",
		"lastmodified":"Last Modified: October 6, 2025",
		"source":"https://glennsqlperformance.com/ https://github.com/amachanic/sp_whoisactive/releases",
		"url":"https://glennsqlperformance.com/ https://sqlserverperformance.wordpress.com/ YouTube: https://bit.ly/2PkoAM1 Blue Sky: https://bsky.app/profile/glennalanberry.bsky.social https://github.com/amachanic/sp_whoisactive/releases", 		
		"comments":"-- Diagnostic Queries are available here -- https://glennsqlperformance.com/resources/ -- YouTube video demonstrating these queries -- https://bit.ly/3aXNDzJ -- Please make sure you are using the correct version of these diagnostic queries for your version of SQL Server -- If you like PowerShell, there is a very useful community solution for running these queries in an automated fashion -- https://dbatools.io/ -- Invoke-DbaDiagnosticQuery -- https://docs.dbatools.io/Invoke-DbaDiagnosticQuery https://github.com/amachanic/sp_whoisactive/releases",
		"copyright":"--****************************************************************************** --*   Copyright (C) 2025 Glenn Berry --*   All rights reserved.  --* --* --*   You may alter this code for your own *non-commercial* purposes. You may --*   republish altered code as long as you include this copyright and give due credit.  --* --* --*   THIS CODE AND INFORMATION ARE PROVIDED 'AS IS' WITHOUT WARRANTY OF --*   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED  --*   TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A --*   PARTICULAR PURPOSE.  --* --***************************************************************************** ; (C) 2017 Adam Machanic"
	},
	"queries": [
		{
			"name": "MissingIndices",
			"description": "Missing Indexes for all databases by Index Advantage  (Query 36) (Missing Indexes All Databases)",
			"query": "SELECT CONVERT(decimal(18,2), migs.user_seeks * migs.avg_total_user_cost * (migs.avg_user_impact * 0.01)) AS [index_advantage], CONVERT(nvarchar(25), migs.last_user_seek, 20) AS [last_user_seek],mid.[statement] AS [Database.Schema.Table], COUNT(1) OVER(PARTITION BY mid.[statement]) AS [missing_indexes_for_table], COUNT(1) OVER(PARTITION BY mid.[statement], mid.equality_columns) AS [similar_missing_indexes_for_table], mid.equality_columns, mid.inequality_columns, mid.included_columns, migs.user_seeks, CONVERT(decimal(18,2), migs.avg_total_user_cost) AS [avg_total_user_,cost], migs.avg_user_impact, REPLACE(REPLACE(LEFT(st.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text] FROM sys.dm_db_missing_index_groups AS mig WITH (NOLOCK) INNER JOIN sys.dm_db_missing_index_group_stats_query AS migs WITH(NOLOCK) ON mig.index_group_handle = migs.group_handle CROSS APPLY sys.dm_exec_sql_text(migs.last_sql_handle) AS st INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK) ON mig.index_handle = mid.index_handle ORDER BY index_advantage DESC OPTION (RECOMPILE);",
			"notes":"Getting missing index information for all of the databases on the instance is very useful Look at last user seek time, number of user seeks to help determine source and importance Also look at avg_user_impact and avg_total_user_cost to help determine importance SQL Server is overly eager to add included columns, so beware Do not just blindly add indexes that show up from this query!!!"
		},
		{
			"name": "GetTopWaits",
			"description": "Isolate top waits for server instance since last restart or wait statistics clear  (Query 42) (Top Waits). Clear Wait Stats with this command, DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR) so you can start clean if need be.",
			"query": "WITH [Waits] AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS], (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS], signal_wait_time_ms / 1000.0 AS [SignalS], waiting_tasks_count AS [WaitCount], 100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage], ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum] FROM sys.dm_os_wait_stats WITH (NOLOCK) WHERE [wait_type] NOT IN ( N'AZURE_IMDS_VERSIONS', N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP', N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE', N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE', N'CXCONSUMER', N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT',  N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE',  N'MEMORY_ALLOCATION_EXT', N'ONDEMAND_TASK_QUEUE', N'PARALLEL_REDO_DRAIN_WORKER', N'PARALLEL_REDO_LOG_CACHE', N'PARALLEL_REDO_TRAN_LIST', N'PARALLEL_REDO_WORKER_SYNC', N'PARALLEL_REDO_WORKER_WAIT_WORK', N'PREEMPTIVE_HADR_LEASE_MECHANISM', N'PREEMPTIVE_SP_SERVER_DIAGNOSTICS', N'PREEMPTIVE_OS_LIBRARYOPS', N'PREEMPTIVE_OS_COMOPS', N'PREEMPTIVE_OS_CRYPTOPS', N'PREEMPTIVE_OS_PIPEOPS', N'PREEMPTIVE_OS_AUTHENTICATIONOPS', N'PREEMPTIVE_OS_GENERICOPS', N'PREEMPTIVE_OS_VERIFYTRUST', N'PREEMPTIVE_OS_DELETESECURITYCONTEXT', N'PREEMPTIVE_OS_REPORTEVENT', N'PREEMPTIVE_OS_FILEOPS', N'PREEMPTIVE_OS_DEVICEOPS', N'PREEMPTIVE_OS_QUERYREGISTRY', N'PREEMPTIVE_OS_WRITEFILE', N'PREEMPTIVE_OS_WRITEFILEGATHER', N'PREEMPTIVE_XE_CALLBACKEXECUTE', N'PREEMPTIVE_XE_DISPATCHER', N'PREEMPTIVE_XE_GETTARGETSTATE', N'PREEMPTIVE_XE_SESSIONCOMMIT', N'PREEMPTIVE_XE_TARGETINIT', N'PREEMPTIVE_XE_TARGETFINALIZE', N'POPULATE_LOCK_ORDINALS', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'PWAIT_DIRECTLOGCONSUMER_GETNEXT', N'PWAIT_EXTENSIBILITY_CLEANUP_TASK', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_ASYNC_QUEUE', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SOS_WORK_DISPATCHER', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SOS_WORKER_MIGRATION', N'VDI_CLIENT_OTHER', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'STARTUP_DEPENDENCY_MANAGER', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'WAIT_XTP_RECOVERY', N'XE_BUFFERMGR_ALLPROCESSED_EVENT', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_LIVE_TARGET_TVF', N'XE_TIMER_EVENT') AND waiting_tasks_count > 0) SELECT MAX (W1.wait_type) AS [WaitType], CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage], CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec], CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec], CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec],  CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec], CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec], CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec], MAX (W1.WaitCount) AS [Wait Count], CAST (N'https://www.sqlskills.com/help/waits/' + W1.wait_type AS XML) AS [Help/Info URL] FROM Waits AS W1 INNER JOIN Waits AS W2 ON W2.RowNum <= W1.RowNum GROUP BY W1.RowNum, W1.wait_type HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99  OPTION (RECOMPILE);",
			"notes":"Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure."
		},
		{
			"name": "DetectBlocking",
			"description": "Detect blocking (run multiple times)  (Query 45) (Detect Blocking)",
			"query": "SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database], t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req], t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time], (SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK) CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) WHERE r.session_id = t1.request_session_id) AS [waiter_batch], (SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, (CASE WHEN r.statement_end_offset = -1 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 ELSE r.statement_end_offset END - r.statement_start_offset)/2) FROM sys.dm_exec_requests AS r WITH (NOLOCK) CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt WHERE r.session_id = t1.request_session_id) AS [waiter_stmt], t2.blocking_session_id AS [blocker sid], (SELECT [text] FROM sys.sysprocesses AS p CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) WHERE p.spid = t2.blocking_session_id) AS [blocker_batch] FROM sys.dm_tran_locks AS t1 WITH (NOLOCK) INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK) ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);",
			"notes":"Helps troubleshoot blocking and deadlocking issues The results will change from second to second on a busy system You should run this query multiple times when you see signs of blocking"
		},
		{
			"name": "PageLevelContention",
			"description": "Show page level contention (Query 46) (Page Contention)",
			"query": "SELECT er.session_id, er.wait_type, er.wait_resource, OBJECT_NAME(pinfo.[object_id], pinfo.database_id) AS [object_name], er.blocking_session_id, er.command, SUBSTRING(st.text, (er.statement_start_offset/2)+1, ((CASE er.statement_end_offset WHEN -1 THEN DATALENGTH(st.text) ELSE er.statement_end_offset END - er.statement_start_offset)/2) + 1) AS statement_text, DB_NAME(pinfo.database_id) AS [Database Name],  pinfo.[file_id], pinfo.page_id, pinfo.[object_id], pinfo.index_id, pinfo.page_type_desc FROM sys.dm_exec_requests AS er WITH (NOLOCK) CROSS APPLY sys.dm_exec_sql_text(er.sql_handle) AS st CROSS APPLY sys.fn_PageResCracker(er.page_resource) AS r CROSS APPLY sys.dm_db_page_info(r.[db_id], r.[file_id], r.page_id, N'DETAILED') AS pinfo WHERE  er.wait_type LIKE N'%page%' OPTION (RECOMPILE);",
			"notes":"Show page level contention ."
		},
		{
			"name": "MissingDBIndices",
			"description": "Missing Indexes for current database by Index Advantage  (Query 72) (Missing Indexes)",
			"query": "SELECT CONVERT(decimal(18,2), migs.user_seeks * migs.avg_total_user_cost * (migs.avg_user_impact * 0.01)) AS [Index Advantage], CONVERT(nvarchar(25), migs.last_user_seek, 20) AS [Last User Seek], mid.[statement] AS [Database.Schema.Table], COUNT(1) OVER(PARTITION BY mid.[statement]) AS [missing_indexes_for_table], COUNT(1) OVER(PARTITION BY mid.[statement], mid.equality_columns) AS [similar_missing_indexes_for_table],  mid.equality_columns, mid.inequality_columns, mid.included_columns, migs.user_seeks,  CONVERT(decimal(18,2), migs.avg_total_user_cost) AS [Avg Total User Cost],  CONVERT(decimal(18,2), migs.avg_user_impact) AS [Avg User Impact], REPLACE(REPLACE(LEFT(st.[text], 512), CHAR(10),''), CHAR(13),'') AS [Short Query Text], OBJECT_NAME(mid.[object_id]) AS [Table Name], p.[rows] AS [Table Rows] FROM sys.dm_db_missing_index_groups AS mig WITH (NOLOCK) INNER JOIN sys.dm_db_missing_index_group_stats_query AS migs WITH(NOLOCK) ON mig.index_group_handle = migs.group_handle CROSS APPLY sys.dm_exec_sql_text(migs.last_sql_handle) AS st INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)  ON mig.index_handle = mid.index_handle INNER JOIN sys.partitions AS p WITH (NOLOCK) ON p.[object_id] = mid.[object_id] WHERE mid.database_id = DB_ID() AND p.index_id < 2 ORDER BY [Index Advantage] DESC OPTION (RECOMPILE);",
			"notes":"This is useful to find out the version of SQL Server being used."
		},
		{
			"name": "GetLockWaits",
			"description": "Get lock waits for current database (Query 82) (Lock Waits)",
			"query": "SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],SUM(ios.index_lock_promotion_attempt_count) AS [total index_lock_promotion_attempt_count],SUM(ios.index_lock_promotion_count) AS [ios.index_lock_promotion_count],SUM(ios.page_lock_wait_count) AS [total_page_lock_waits], SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms], SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms] FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios INNER JOIN sys.objects AS o WITH (NOLOCK) ON ios.[object_id] = o.[object_id] INNER JOIN sys.indexes AS i WITH (NOLOCK) ON ios.[object_id] = i.[object_id] AND ios.index_id = i.index_id WHERE o.[object_id] > 100 GROUP BY o.name, i.name, ios.index_id, ios.partition_number HAVING SUM(ios.page_lock_wait_in_ms) + SUM(row_lock_wait_in_ms) > 0 ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);",
			"notes":"This query is helpful for troubleshooting blocking and deadlocking issues"
		},
		{
			"name": "GetTopAverageElapsedTime",
			"description": "Get top average elapsed time queries for entire instance (Query 54) (Top Avg Elapsed Time Queries)",
			"query": "SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text],  qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time],qs.min_elapsed_time, qs.max_elapsed_time, qs.last_elapsed_time,qs.execution_count AS [Execution Count],  qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], qs.total_worker_time/qs.execution_count AS [Avg Worker Time],CASE WHEN CONVERT(nvarchar(max), qp.query_plan) COLLATE Latin1_General_BIN2 LIKE N'%<MissingIndexes>%' THEN 1 ELSE 0 END AS [Has Missing Index],qs.creation_time AS [Creation Time] ,t.[text] AS [Complete Query Text], qp.query_plan AS [Query Plan] FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK) CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp  ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);",
			"notes":"Helps you find the highest average elapsed time queries across the entire instance Can also help track down parameter sniffing issues."
		},
		{
			"name": "TopLogicalReads",
			"description": "Get top total logical reads queries for entire instance (Query 53) (Top Logical Reads Queries)",
			"query": "SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name],REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text], qs.total_logical_reads AS [Total Logical Reads],qs.min_logical_reads AS [Min Logical Reads],qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],qs.max_logical_reads AS [Max Logical Reads], qs.min_worker_time AS [Min Worker Time],qs.total_worker_time/qs.execution_count AS [Avg Worker Time], qs.max_worker_time AS [Max Worker Time], qs.min_elapsed_time AS [Min Elapsed Time], qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], qs.max_elapsed_time AS [Max Elapsed Time], qs.execution_count AS [Execution Count],  CASE WHEN CONVERT(nvarchar(max), qp.query_plan) COLLATE Latin1_General_BIN2 LIKE N'%<MissingIndexes>%' THEN 1 ELSE 0 END AS [Has Missing Index], qs.creation_time AS [Creation Time] ,t.[text] AS [Complete Query Text], qp.query_plan AS [Query Plan]  FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK) CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp  ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);",
			"notes":"Helps you find the most expensive queries from a memory perspective across the entire instance Can also help track down parameter sniffing issues."
		},
		{
			"name": "FindBlockLeaders",
			"description": "Find what sessions are blocking other sessions",
			"query": "EXEC sp_WhoIsActive @Output_Column_List = '[session_id][block%][login%][additional%][%]', @find_block_leaders = 1, @sort_order = '[blocked_session_count] DESC', @get_additional_info=1",
			"notes":"SP Who is Active Needs to be Installed - Oftentimes blocking situations are a bit more complex than one session blocking some other request. In busy systems blocking chains can build up that include dozens or even hundreds of requests, all waiting on one another."
		},
		{
			"name": "FindLocks",
			"description": "Find what locks are waiting on other locks",
			"query": "EXEC sp_WhoIsActive @Output_Column_List = '[locks][session_id][block%][login%][additional%][%]', @get_locks = 1, @get_additional_info=1    ",
			"notes":"SP Who is Active Needs to be Installed - Behind every block is something causing the block. Something that, without which, there could be no block. And that thing is called a lock."
		}
	]
}